\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Report\\Node Messenger}

\author{Team \#24, Node Messenger
		\\ Tasin Ahmed - ahmedm31
		\\ Shardool Patel - pates25
		\\ Omar Elemary - elemaryo
}

\date{\today}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

This document ...

\newpage
\section{Functional Requirements Evaluation}
	\subsection{User Inputs}
	We tested all the input fields in our messenger app. Through testing, we determined that the login and signup feature work as intended. The messenger returns an error if a field is empty while logging in or registering. It returns an error if the email entered is invalid, if the passwords do not match, and if the password is less than 6 characters. While logging in, the console returns errors correctly if the email and password entered are incorrect. While adding people to a new conversation, the messenger ensures that an email is entered and that it is valid. The messenger prevents the user from sending a message if the message box is empty. Pressing 'Enter' or clicking the 'Send' button both send messages correctly. By testing these user inputs we are able to ensure that the core functions of our messenger work as intended.
	\subsection{Data Storage}
	Testing was done to ensure that data sent from Node Messenger was being stored correctly in the firebase database. Once a user creates a new account, Node Messenger correctly stores their Name, Email, and Password in the database. After a message a sent by the user, it is sent to our database and stored. The database stores the messages, the time it was sent at, the chat it was sent to, and the user it was sent by. Our database consists of 3 collections: Messages, Users, and Conversations. By testing, we made sure that the information being sent to the database gets stored into their respective collection.
	\subsection{Data Retrieval}
	Node Messenger is able to look through the firebase database, and retrieve the necessary data. This is done when a new user is signing up to the website. The messenger must look through our database and return an error if the user email already exists in our database. A similar procedure occurs during login. The messenger must take the entered email and password, and allow the user to login if the credentials match that on the database. The messenger is able to display the correct messages to the correct chat, display the name of the user it was sent by, and the time it was sent at. When adding a user to a conversation, the messenger again looks through our database and ensures the email address that was entered is valid.

\section{Nonfunctional Requirements Evaluation}
	\subsection{Look and Feel}
	For the look and feel of the messenger, we wanted it to look visually appealing. For the theme of the messenger, we tried analogous, complementary, triad, and many shades of color, and felt our current theme suits our messenger the best. After hosting our messenger on Github Pages, we shared the URL with many of our classmates, family, and friends. Many of them provided us with valuable feedback that helped us to further improve our messenger to suit the needs of the majority of the users. Most of the feedback we got from them was very positive and assured us that our messenger achieved the goal of being user-friendly.  
	\subsection{Usability and Humanity}
	Node Messenger is made to be catered towards everyone. To achieve this, we used one of the main methods of software design – Abstraction. This means if a user has used any messaging apps before, they will have no problem migrating to Node Messenger. All the features in our messenger are self-intuitive and do not take much time to get used to. Node Messenger is currently hosted on Github pages making it accessible to anyone the planet. It is able to run on any platform without problems. However, during testing, we realized that our messenger does not respond well to smaller screen sizes. Our goal for our servers was to be able to hold as many people as possible. Currently, due to the limitations of our database, Node Messenger is able to serve about 50 people at once. 
	\subsection{Performance}
	Node Messenger performs very well under normal use. The tests were performed on a Windows machine with Intel i5, 1.60GHz, and  8 GB RAM. Our performance goals for Node Messenger was for it to load the messenger, send messages, receive messages, and load past messages quickly. We timed each of these procedures, and the results prove to be very fast as we intended. 
	\begin{center}
	\begin{tabular}{c c}
	\hline 
	\textbf{Description} & \textbf{Time} \\ 
	\hline 
	Messenger Load Time & 1.2 s \\ 
	Message Send Time & 0.36 s \\ 
	Message Receive Time & 0.56 s \\ 
	Past Messages Load Time & 0.33 s \\ 
	\hline 
	\end{tabular} 
	\end{center}
	\subsection{Operational and Environmental}
	Node Messenger is able to work on all platforms. However, it performs the best on Windows. Due to the scale of this project and the lack of time, responsiveness was not fully implemented. Meaning Node Messenger has difficulty loading components properly on smaller screens. This does not mean the messenger is unusable on these platforms. All functions of the messenger perform as intended. None of our testers have reported any other errors occurring when attempting to load on platforms other than windows. 
	\subsection{Maintainability and Support}
	All functions in Node Messenger has been tested thoroughly to ensure everything performs as intended. We want to make sure to keep the downtime and maintenance to a minimum. All of the source code is well structured and documented to help us quickly find errors, and fix them. This will also help programmers navigate through our code if they want to add any new features to Node Messenger. 
	\subsection{Security}
	All user information is kept safely in our firebase database. Node Messenger will not save any of the personal information nor will it share them with other parties.
	\subsection{Legal}
	Node Messenger abides by all rules and regulations. The public will have access to the open-source project. If they would like to improve our messenger, they are free to do so.  
	
\section{Comparison to Existing Implementation}	

\section{Unit Testing}
As we stated in our test plan, the majority of the testing has been done with Jest. We tested the rendering of the messenger, as well as the calls being sent to our firebase database using Jest’s snapshot feature. We tested most of the functions used by the messenger to ensure that maintenance can be kept to a minimum. Refer to the Trace to Modules table to visualize how test cases use each module.

\section{Changes Due to Testing}
Due to testing and constant feedback from our testers, we were able to make several improvements to Node Messenger. Testing helped us to uncover hidden bugs that occur through normal use of the messenger. Through testing, we discovered a bug when nothing is entered in the message box and the user presses send. The messenger would send an empty message bubble to the chat anyways. Another bug we discovered while testing was when a very long sentence is entered in the chat. The long message would not automatically go to the next line. We mixed it easily by wrapping the text with the message bubble. One of our classmates who tested the messenger notified us that he was able to login to someone else’s account using a random password. We fixed it by looking through our firebase database and changing how data is searched from our messenger. 

\section{Automated Testing}
\subsection{Validation of User Input}
\subsubsection{Inputs}
Empty String, invalid emails and valid emails 
\subsubsection{Outputs}
Appropriate Error shown if input invalid. Chat screen if valid input.
\subsubsection{Procedures}
The test will be performed using the Jest framework. Based on the input, the render tree will be tested for appropriate output.
\subsection{Successful sign up}
\subsubsection{Inputs}
Email address and password
\subsubsection{Outputs}
Pop up indicating user successfully signed up. User redirected to chat screen
\subsubsection{Procedures}
The test will be automated with the testing framework jest. The user data will be used for sign up and will be checked against the list of users in the database.
\subsection{Successful Login}
\subsubsection{Inputs}
email address and password used for login
\subsubsection{Outputs}
Redirect user to the chat screen
\subsubsection{Procedures}
The test will be automated with the testing framework jest. The user data will be used for login and the authentication state will be checked to see if the login was successful.
\subsection{Authentication State Persistence}
\subsubsection{Inputs}
User reloads the site
\subsubsection{Outputs}
If the computer is listed as a user trusted computer, keep the user logged in.
\subsubsection{Procedures}
The test will be automated with the testing framework jest. The change in authentication state will be used to determine if the user is automatically signed if the page is reloaded.
\subsection{User message renders on input box}
\subsubsection{Inputs}
User starts entering message in input box
\subsubsection{Outputs}
Message shows up in the input box
\subsubsection{Procedures}
The test will be done using jest framework. The react tree will be checked for the rendered message in the input box.
\subsection{User message renders on screen}
\subsubsection{Inputs}
User enters message in the input box
\subsubsection{Outputs}
Message shows up on the right side in the conversation windows
\subsubsection{Procedures}
The test will be done using jest framework. The react tree will be checked for the rendered message.
\subsection{Received message renders on screen}
\subsubsection{Inputs}
N/A
\subsubsection{Outputs}
Message received shows up on the right side in the conversation windows
\subsubsection{Procedures}
The test will be done using jest framework. The react tree will be checked for the rendered message.
\subsection{Instant Messaging}
\subsubsection{Inputs}
N/A
\subsubsection{Outputs}
Send/Receive messages
\subsubsection{Procedures}
This manual test will be performed using two instances of the application. The test will check if the sending and receiving of messages happen within a few seconds of pressing the send button.
\subsection{Contacts}
\subsubsection{Inputs}
Add a contact
\subsubsection{Outputs}
Contact is rendered on user's contacts list
\subsubsection{Procedures}
The test will  be performed using Jest. The rendered contact list will be tested for the updated state.
\subsection{Contacts}
\subsubsection{Inputs}
Add a contact
\subsubsection{Outputs}
Upon adding a contact the database should add the contact to user's contact list
\subsubsection{Procedures}
This manual test will be performed using jest. The user's contact list will be tested before and after the addition of few contacts. Edge cases will cover the testing of adding contacts that are not in the system.
\subsection{Chat history}
\subsubsection{Inputs}
Log-out and Log-in back to the chat
\subsubsection{Outputs}
The chat history should be rendered and the message history should be accessible.
\subsubsection{Procedures}
This manual test will be performed using jest. The user's contact list will be tested before and after the addition of few contacts. Edge cases will cover the testing of adding contacts that are not in the system.
\subsection{To test the look and feel of the application}
\subsubsection{Inputs}
N/A
\subsubsection{Outputs}
N/A
\subsubsection{Procedures}
The UI/UX tests will subjectively give a qualitative result of how the system feels in terms for ease of use ,appearance and responsiveness. This test will carried out by using the application for a certain amount of time.
\subsection{Time taken to send and receive messages (acceptable: $<$ 2 sec)}
\subsubsection{Inputs}
Message sent
\subsubsection{Outputs}
Server callback with approximated time.
\subsubsection{Procedures}
This test will be automated by the jest framework. The server will send a ping once a message is received, which will then used to estimate the average time taken to send and receive messages.
\subsection{Scrolling through a large amount of messages}
\subsubsection{Inputs}
Scroll action
\subsubsection{Outputs}
Scrolling message area
\subsubsection{Procedures}
This test will be performed manually to see if the scrolling behaviour and responsiveness is affected by large number of messages being loaded in on the client side
\subsection{Server responsiveness when large group is active}
\subsubsection{Inputs}
Messages being sent by everyone
\subsubsection{Outputs}
Receiving messages
\subsubsection{Procedures}
This test will be performed using jest. The time from the message being sent to the server and receiving a callback will be tested to see the responsiveness of the server when under heavy load
\subsection{Tests users access level}
\subsubsection{Inputs}
User tries to access the page that routes to a different user's contact list
\subsubsection{Outputs}
Unauthorized access error
\subsubsection{Procedures}
The test will be automated using jest. jest will try to access unauthorized pages under a user and check if the appropriate error is thrown back.
\subsection{Mobile/Tablet UI/UX}
\subsubsection{Inputs}
Log-in and send a message
\subsubsection{Outputs}
Rendered message on screen
\subsubsection{Procedures}
The Mobile/Tablet UI/UX tests will subjectively give a qualitative result of how the system performs on different devices. Google Chrome Dev Tools along with our personal devices will be used for this test.
		
\section{Trace to Requirements}
		
\section{Trace to Modules}		

\section{Code Coverage Metrics}

\bibliographystyle{plainnat}

\bibliography{SRS}

\end{document}